# Hoisting 호이스팅
> 함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 요호 범위의 최상단에 선언하는 것  
> 선언/초기화/할당이 분리된다  
- var 변수 선언과 함수 선언문에서만 호이스팅이 일어난다.
    - var 변수/함수의 **선언**만 위로 끌어 올려지고, **할당**은 끌어 올려지지 않는다.
    - let/const 변수 선언과 함수 표현식에서는 호이스팅이 발생하지 않는다.  

**호이스팅 우선순위**  
- 변수 선언이 함수 선언보다 위로 끌어올려진다.
- 값 할당 O 변수와 값 할당 변수 X에서 호이스팅
  - 값 할당 O 변수는 변수가 함수 선언문을 덮어쓴다.
  - 값 할당 X 변수는 함수 선언문이 변수를 덮어쓴다.

**주의할점**
- 코드의 가독성과 유지보수를 위해 호이스팅이 일어나지 않도록 한다.
  - 함수와 변수를 가급적 상단부에 선언하면, 호이스팅으로 인한 스코프 꼬임 현상은 방지
  - let/const 사용

# Scope 스코프
> 어떤 변수들에 접근할 수 있는지 정의

- 전역 스코프
  - 변수가 함수 바깥이나 중괄호 바깥에서 선언
  - 코드 모든곳에서 해당 변수 사용 가능
  - 전역 스코프에 선언을 할 수 있어도 안하는것이 좋다.
- 지역 스코프
  - 특정 부분에서만 사용할 수 있는 변수
  - 함수 스코프
    - 함수 내부에서 변수 선언
  - 블록 스코프
    - 중괄호 내에서 const 또는 let으로 변수 선언
    - 함수 스코프의 서브셋이다.

**함수 호이스팅과 스코프**  
함수가 함수 선언식으로 선언되면, 현재 스코프의 최상단으로 호이스팅 된다.  
함수 표현식으로 선언되면, 함수는 현재 스코프의 최상단으로 호이스팅되지 않는다.    

**네스팅된 스코프**
함수가 다른 함수 내부에서 정의되었다면, 내부함수는 외부 함수의 변수에 접근 할 수 있다.  
렉시컬 스코핑(lexical scoping)   
외부 함수는 내부 함수의 변수에 접근할 수 없다.

# Closure 클로저
> 함수와 함수가 선언된 어휘적 환경의 조합  
내부에 작성된 함수  
외부 함수의 변수를 사용할 수 있다.

**목적**
1. 사이드 이펙트 제어하기
2. private 변수 생성

**사이드 이펙트 제어하기**  
함수에서 값을 반환할 때 제외하고 무언가를 행할 때 발생  
보통 Ajax나 timeout 같이 코드 흐름을 방해하는 것들이 신경쓰일 떄 활용  

**private 변수**  
- 함수 내의 변수
- 함수 바깥에서 접근할 수 없다.
- 해당 변수들에 접근해야 할 떄 클로저를 활용한다.

**특권 함수(privileged function)**  
함수 바깥에서  내부 함수를 노출하는 함수(클로저)  

**스코프 디버깅하기**
1. debugger 키워드 코드 추가하기
   - 실행을 일시정지하여 디버깅하기
2.  직접 breakpoint 추가하기